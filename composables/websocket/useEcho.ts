import Echo from 'laravel-echo'
import type { Channel, PresenceChannel } from 'pusher-js'
import { ref, onMounted, onUnmounted } from 'vue'
import type { EchoConfig, WebSocketRole, WebSocketChannel } from '../../types/websocket/echo'

let echoInstance: Echo | null = null
let isInitializing = false
let isInitialized = false

export const useEcho = () => {
  const isConnected = ref(false)
  const error = ref<Error | null>(null)
  const activeChannels = ref<Map<string, Channel | PresenceChannel>>(new Map())
  const config = useRuntimeConfig()

  const initializeEcho = async (echoConfig: EchoConfig) => {
    // Evitar m√∫ltiples inicializaciones
    if (isInitializing) {
      
      return
    }
    
    if (isInitialized && echoInstance) {
      
      return echoInstance
    }

    isInitializing = true
    
    try {
      if (typeof window !== 'undefined') {
        try {
          const PusherJs = await import('pusher-js')
          ;(window as any).Pusher = PusherJs.default

          // Habilitar logs de Pusher
          ;(window as any).Pusher.logToConsole = true
          
        } catch (error) {
          console.error('‚ùå Error importando Pusher:', error)
          throw error
        }
      }
      
      console.log('üîÑ Iniciando Echo con config:', {
        ...echoConfig,
        key: config.public.pusherAppKey,
        cluster: config.public.pusherAppCluster
      })

      const finalConfig = {
        broadcaster: 'pusher',
        key: config.public.pusherAppKey,
        cluster: config.public.pusherAppCluster,
        ...echoConfig,
        enabledTransports: ['ws', 'wss']
        // No sobrescribir forceTLS, usar el valor del echoConfig
      }
      
      console.log('üîß Configuraci√≥n final de Echo:', finalConfig)
      
      echoInstance = new Echo(finalConfig)

      // Agregar listeners globales de Pusher
      if ((echoInstance as any).connector?.pusher) {
        const pusher = (echoInstance as any).connector.pusher
        const connection = pusher.connection
        
        console.log('üîç Verificando m√©todos de conexi√≥n Pusher:', {
          hasConnection: !!connection,
          connectionType: typeof connection,
          hasBind: typeof connection?.bind === 'function',
          hasOn: typeof connection?.on === 'function',
          hasAddEventListener: typeof connection?.addEventListener === 'function'
        })
        
        // Intentar diferentes m√©todos para registrar eventos de conexi√≥n
        if (connection && typeof connection === 'object') {
          // M√©todo 1: bind (Pusher tradicional)
          if (typeof connection.bind === 'function') {
            
            connection.bind('connected', () => {
              
              console.log('üîå Socket ID:', echoInstance?.socketId())
            })

            connection.bind('disconnected', () => {
              
            })

            connection.bind('error', (err: any) => {
              console.error('‚ùå Pusher: Error de conexi√≥n', err)
            })
          }
          // M√©todo 2: on (alternativa)
          else if (typeof connection.on === 'function') {
            
            connection.on('connected', () => {
              
              console.log('üîå Socket ID:', echoInstance?.socketId())
            })

            connection.on('disconnected', () => {
              
            })

            connection.on('error', (err: any) => {
              console.error('‚ùå Pusher: Error de conexi√≥n', err)
            })
          }
          // M√©todo 3: addEventListener (DOM)
          else if (typeof connection.addEventListener === 'function') {
            
            connection.addEventListener('connected', () => {
              
              console.log('üîå Socket ID:', echoInstance?.socketId())
            })

            connection.addEventListener('disconnected', () => {
              
            })

            connection.addEventListener('error', (err: any) => {
              console.error('‚ùå Pusher: Error de conexi√≥n', err)
            })
          }
          else {
            console.warn('‚ö†Ô∏è No se encontraron m√©todos v√°lidos para eventos de conexi√≥n Pusher')
            console.warn('‚ö†Ô∏è M√©todos disponibles:', Object.getOwnPropertyNames(connection))
          }
        } else {
          console.warn('‚ö†Ô∏è Objeto de conexi√≥n Pusher no v√°lido')
        }
      }

      isConnected.value = true
      error.value = null
      isInitialized = true
      
    } catch (err) {
      error.value = err as Error
      console.error('‚ùå Error inicializando Echo:', err)
    } finally {
      isInitializing = false
    }
  }

  const subscribeToChannel = (channel: WebSocketChannel) => {
    if (!echoInstance) {
      throw new Error('Echo instance not initialized')
    }

    // Verificar si ya estamos suscritos a este canal para evitar duplicados
    if (activeChannels.value.has(channel.name)) {
      
      return activeChannels.value.get(channel.name)
    }

    
    let channelInstance: any

    try {
      switch (channel.type) {
        case 'private':
          
          channelInstance = echoInstance.private(channel.name)
          console.log(`üîß Canal privado creado:`, channelInstance)
          break
        case 'presence':
          
          channelInstance = echoInstance.join(channel.name)
          console.log(`üîß Canal de presencia creado:`, channelInstance)
          break
        default:
          throw new Error(`Tipo de canal no soportado: ${channel.type}`)
      }

      // Agregar listeners de estado del canal
      if (channelInstance) {
        try {
          // Intentar diferentes m√©todos para los eventos de suscripci√≥n
          if (typeof channelInstance.bind === 'function') {
            channelInstance.bind('pusher:subscription_succeeded', () => {
              
            })

            channelInstance.bind('pusher:subscription_error', (err: any) => {
              console.error(`‚ùå Error en suscripci√≥n al canal ${channel.name}:`, err)
            })
          } else if (typeof channelInstance.listen === 'function') {
            channelInstance.listen('pusher:subscription_succeeded', () => {
              
            })

            channelInstance.listen('pusher:subscription_error', (err: any) => {
              console.error(`‚ùå Error en suscripci√≥n al canal ${channel.name}:`, err)
            })
          } else {
            
          }
        } catch (err) {
          console.warn(`‚ö†Ô∏è Error registrando eventos de suscripci√≥n para ${channel.name}:`, err)
        }
      }

      // Registrar los manejadores de eventos para este canal
      const registeredEvents = new Set()
      channel.handlers.forEach(({ event, callback }) => {
        // Evitar registrar el mismo evento m√∫ltiples veces
        const eventKey = `${channel.name}:${event}`
        if (registeredEvents.has(eventKey)) {
          
          return
        }
        registeredEvents.add(eventKey)
        
        console.log(`üîç Tipo de canalInstance:`, typeof channelInstance)
        console.log(`üîç M√©todos disponibles:`, Object.getOwnPropertyNames(channelInstance))
        
        try {
          // Intentar diferentes m√©todos para registrar eventos
          if (channelInstance && typeof channelInstance === 'object') {
            // M√©todo 1: bind (Pusher) - PRIORITARIO para eventos de Pusher
            if (typeof channelInstance.bind === 'function') {
              
              channelInstance.bind(event, (data: any) => {
                console.log(`üì® Evento recibido '${event}' en canal '${channel.name}':`, data)
                callback(data)
              })
            }
            // M√©todo 2: Acceder al objeto pusher del canal para usar bind
            else if (channelInstance.pusher && typeof channelInstance.pusher.bind === 'function') {
              
              channelInstance.pusher.bind(event, (data: any) => {
                console.log(`üì® Evento recibido '${event}' en canal '${channel.name}':`, data)
                callback(data)
              })
            }
            // M√©todo 3: listen (Laravel Echo) - Para eventos de Laravel
            else if (typeof channelInstance.listen === 'function') {
              
              channelInstance.listen(event, (data: any) => {
                console.log(`üì® Evento recibido '${event}' en canal '${channel.name}':`, data)
                callback(data)
              })
            }
            // M√©todo 4: on (alternativa)
            else if (typeof channelInstance.on === 'function') {
              
              channelInstance.on(event, (data: any) => {
                console.log(`üì® Evento recibido '${event}' en canal '${channel.name}':`, data)
                callback(data)
              })
            }
            // M√©todo 5: addEventListener (DOM)
            else if (typeof channelInstance.addEventListener === 'function') {
              
              channelInstance.addEventListener(event, (data: any) => {
                console.log(`üì® Evento recibido '${event}' en canal '${channel.name}':`, data)
                callback(data)
              })
            }
            else {
              console.warn(`‚ö†Ô∏è El canal no soporta ning√∫n m√©todo conocido para el evento: ${event}`)
              console.warn(`‚ö†Ô∏è M√©todos disponibles:`, Object.getOwnPropertyNames(channelInstance))
              console.warn(`‚ö†Ô∏è Objeto pusher disponible:`, !!channelInstance.pusher)
              if (channelInstance.pusher) {
                console.warn(`‚ö†Ô∏è M√©todos del objeto pusher:`, Object.getOwnPropertyNames(channelInstance.pusher))
              }
            }
          } else {
            console.error(`‚ùå channelInstance no es un objeto v√°lido:`, channelInstance)
          }
        } catch (err) {
          console.error(`‚ùå Error registrando evento '${event}':`, err)
        }
      })

      activeChannels.value.set(channel.name, channelInstance)
      return channelInstance
    } catch (err) {
      console.error(`‚ùå Error suscribi√©ndose al canal ${channel.name}:`, err)
      throw err
    }
  }

  const subscribeToRoleChannels = (roleConfig: WebSocketRole) => {
    
    roleConfig.channels.forEach(channel => {
      try {
        
        subscribeToChannel(channel)
        
      } catch (err) {
        console.error(`‚ùå Error configurando canal ${channel.name}:`, err)
        // Continuar con otros canales aunque uno falle
      }
    })
  }

  const unsubscribeFromChannel = (channelName: string) => {
    
    const channel = activeChannels.value.get(channelName)
    if (channel) {
      try {
        echoInstance?.leave(channelName)
        activeChannels.value.delete(channelName)
        
      } catch (err) {
        console.error(`‚ùå Error desuscribiendo del canal ${channelName}:`, err)
      }
    }
  }

  const disconnect = () => {
    if (echoInstance) {
      
      activeChannels.value.forEach((_, channelName) => {
        unsubscribeFromChannel(channelName)
      })
      echoInstance.disconnect()
      echoInstance = null
      isConnected.value = false
      isInitialized = false
      isInitializing = false
      
    }
  }

  const resetEcho = () => {
    
    echoInstance = null
    isInitialized = false
    isInitializing = false
    activeChannels.value.clear()
    isConnected.value = false
    error.value = null
  }

  const getActiveChannels = () => {
    const channels = Array.from(activeChannels.value.keys())
    console.log('üìª Canales activos:', channels)
    return channels
  }

  const getChannelStatus = (channelName: string) => {
    const channel = activeChannels.value.get(channelName)
    if (channel) {
      return {
        name: channelName,
        isSubscribed: true,
        type: (channel as any).members ? 'presence' : 'private'
      }
    }
    return null
  }

  onUnmounted(() => {
    disconnect()
  })

  return {
    isConnected,
    error,
    activeChannels,
    initializeEcho,
    subscribeToChannel,
    subscribeToRoleChannels,
    unsubscribeFromChannel,
    disconnect,
    resetEcho,
    getActiveChannels,
    getChannelStatus
  }
}

export const getEchoInstance = () => echoInstance